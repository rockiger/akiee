;; Analyzed by ClojureScript 0.0-2725
{:defs {->PersistentHashSet {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashSet, :variadic false, :max-fixed-arity 3}), :line 7351, :end-line 7351, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, ->ExceptionInfo {:protocol-inline nil, :protocols #{}, :name cljs.core/->ExceptionInfo, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9166, :end-line 9166, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :skip-protocol-flag nil, :test true}, js->clj {:protocol-inline nil, :name cljs.core/js->clj, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x] [x opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 8662, :end-line 8662, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :test true}, sort-by {:protocol-inline nil, :name cljs.core/sort-by, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 3}), :line 1721, :end-line 1721, :max-fixed-arity 3, :fn-var true, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ITransientAssociative {:protocol-symbol true, :name cljs.core/ITransientAssociative, :file "out/cljs/core.cljs", :end-column 36, :column 1, :line 380, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 380, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :test true}, chunk-first {:protocol-inline nil, :name cljs.core/chunk-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2743, :end-line 2743, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, m3-hash-int {:protocol-inline nil, :name cljs.core/m3-hash-int, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 483, :ret-tag number, :end-line 483, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, stepper {:protocol-inline nil, :name cljs.core/stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3140, :end-line 3140, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :test true}, pr-str* {:protocol-inline nil, :name cljs.core/pr-str*, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 431, :end-line 431, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :test true}, eduction {:protocol-inline nil, :name cljs.core/eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8608, :end-line 8608, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :doc "Returns a reducible/iterable/seqable application of\n  the transducer to the items in coll. Note that these applications\t\n  will be performed every time iterator/seq/reduce is called.", :test true}, tree-seq {:protocol-inline nil, :name cljs.core/tree-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 3994, :end-line 3994, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :test true}, unchecked-remainder-int {:protocol-inline nil, :name cljs.core/unchecked-remainder-int, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 2010, :end-line 2010, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :test true}, seq {:protocol-inline nil, :name cljs.core/seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 702, :ret-tag seq, :end-line 702, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :test true}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3596, :record false, :end-line 3596, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :name cljs.core/reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1755, :end-line 1755, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :test true}, INIT {:file "out/cljs/core.cljs", :line 3089, :column 1, :end-line 3089, :end-column 11, :test true, :name cljs.core/INIT}, contains? {:protocol-inline nil, :name cljs.core/contains?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 1618, :ret-tag boolean, :end-line 1618, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :test true}, every? {:protocol-inline nil, :name cljs.core/every?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3291, :ret-tag boolean, :end-line 3291, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :test true}, ->ES6IteratorSeq {:protocol-inline nil, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6IteratorSeq, :variadic false, :max-fixed-arity 3}), :line 791, :end-line 791, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :test true}, Var {:num-fields 3, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/Var, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 637, :record false, :end-line 637, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}}, keep-indexed {:protocol-inline nil, :name cljs.core/keep-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3618, :end-line 3618, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :test true}, ->PersistentQueueSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueueSeq, :variadic false, :max-fixed-arity 4}), :line 4879, :end-line 4879, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :test true}, subs {:protocol-inline nil, :name cljs.core/subs, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 2204, :end-line 2204, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :test true}, set {:protocol-inline nil, :name cljs.core/set, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7582, :end-line 7582, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll.", :test true}, compare-indexed {:protocol-inline nil, :private true, :name cljs.core/compare-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag number, :variadic false, :max-fixed-arity 4}), :line 1676, :end-line 1676, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :test true}, take-last {:protocol-inline nil, :name cljs.core/take-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 3832, :end-line 3832, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :test true}, IndexedSeq {:num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1003, :record false, :declared true, :end-line 1003, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, bit-set {:protocol-inline nil, :name cljs.core/bit-set, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2121, :end-line 2121, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n", :test true}, string-hash-cache-count {:file "out/cljs/core.cljs", :line 510, :column 1, :end-line 510, :end-column 30, :test true, :name cljs.core/string-hash-cache-count}, ->Eduction {:protocol-inline nil, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8593, :end-line 8593, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :test true}, tree-map-add {:protocol-inline nil, :private true, :name cljs.core/tree-map-add, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 5}), :line 6869, :end-line 6869, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found])), :test true}, ->ES6SetEntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5170, :end-line 5170, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, -with-meta {:protocol-inline nil, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 317, :ret-tag clj, :end-line 318, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :test true}, reset-cache {:protocol-inline nil, :private true, :name cljs.core/reset-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 8866, :end-line 8866, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy])), :test true}, ->PersistentArrayMapIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapIterator, :variadic false, :max-fixed-arity 3}), :line 5320, :end-line 5320, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil, :test true}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "out/cljs/core.cljs", :end-column 37, :type true, :column 10, :line 5320, :record false, :end-line 5320, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :name cljs.core/butlast, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 7657, :end-line 7657, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, tail-off {:protocol-inline nil, :private true, :name cljs.core/tail-off, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 4167, :end-line 4167, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, unchecked-subtract-int {:protocol-inline nil, :name cljs.core/unchecked-subtract-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2020, :ret-tag number, :end-line 2020, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -iterator {:protocol-inline nil, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 421, :end-line 422, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, take-nth {:protocol-inline nil, :name cljs.core/take-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7905, :end-line 7905, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :test true}, first {:protocol-inline nil, :name cljs.core/first, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 725, :end-line 725, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :test true}, native-satisfies? {:protocol-inline nil, :name cljs.core/native-satisfies?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 113, :ret-tag boolean, :end-line 113, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!", :test true}, seq? {:protocol-inline nil, :name cljs.core/seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1592, :ret-tag boolean, :end-line 1592, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq", :test true}, -global-hierarchy {:file "out/cljs/core.cljs", :line 8756, :column 1, :end-line 8756, :end-column 34, :private true, :test true, :name cljs.core/-global-hierarchy}, UUID {:num-fields 1, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/UUID, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9146, :record false, :end-line 9146, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}}, -sorted-seq-from {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 347, :ret-tag clj, :end-line 349, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :test true}, println-str {:protocol-inline nil, :name cljs.core/println-str, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8304, :end-line 8304, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "println to a string, returning it", :test true}, linear-traversal-nth {:protocol-inline nil, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1228, :end-line 1228, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :test true}, iterate {:protocol-inline nil, :added "1.0", :name cljs.core/iterate, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 3893, :end-line 3893, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :test true}, -empty {:protocol-inline nil, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 261, :end-line 262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, newline {:protocol-inline nil, :name cljs.core/newline, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8262, :end-line 8262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :test true}, ILookup {:protocol-symbol true, :name cljs.core/ILookup, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 282, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 282, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :test true}, -chunked-rest {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 399, :end-line 401, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, write-all {:protocol-inline nil, :name cljs.core/write-all, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([writer ss]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 1}), :line 8125, :end-line 8125, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer & ss])), :test true}, ->t7633 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7633, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta7634]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t7633, :variadic false, :max-fixed-arity 2}), :line 3059, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7634])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, fn? {:protocol-inline nil, :name cljs.core/fn?, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean any}, :variadic false, :max-fixed-arity 1}), :line 1393, :ret-tag boolean, :end-line 1393, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :test true}, -prefer-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 8918, :end-line 8922, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :test true}, -assoc {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 285, :ret-tag clj, :end-line 288, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :test true}, doall {:protocol-inline nil, :name cljs.core/doall, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 8042, :end-line 8042, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :test true}, keyword-identical? {:protocol-inline nil, :name cljs.core/keyword-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2521, :ret-tag boolean, :end-line 2521, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :test true}, pv-aset {:protocol-inline nil, :private true, :name cljs.core/pv-aset, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4161, :end-line 4161, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val])), :test true}, prefers {:protocol-inline nil, :name cljs.core/prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9140, :end-line 9140, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values", :test true}, -js->clj {:protocol-inline nil, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8659, :end-line 8660, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :test true}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2551, :record false, :end-line 2551, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :name cljs.core/dedupe, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag any, :variadic false, :max-fixed-arity 1}), :line 8566, :end-line 8566, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :test true}, unchecked-editable-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4730, :end-line 4730, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i])), :test true}, ->ES6Iterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 777, :end-line 777, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4153, :record false, :end-line 4153, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :name cljs.core/dissoc, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1379, :end-line 1379, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :test true}, atom {:file "out/cljs/core.cljs", :line 5590, :column 1, :end-line 5590, :end-column 73, :declared true, :test true, :name cljs.core/atom}, bit-shift-right {:protocol-inline nil, :name cljs.core/bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2135, :end-line 2135, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right", :test true}, *clojurescript-version* {:file "out/cljs/core.cljs", :line 16, :column 1, :end-line 16, :end-column 30, :test true, :name cljs.core/*clojurescript-version*}, -first {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 275, :end-line 276, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, peek {:protocol-inline nil, :name cljs.core/peek, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1465, :end-line 1465, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :test true}, IKVReduce {:protocol-symbol true, :name cljs.core/IKVReduce, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 323, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 323, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :test true}, aget {:protocol-inline nil, :name cljs.core/aget, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i] [array i idxs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 192, :end-line 192, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :test true}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "out/cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6463, :record false, :end-line 6463, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 353, :end-line 354, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :test true}, iter {:protocol-inline nil, :name cljs.core/iter, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/t7636 cljs.core/StringIter cljs.core/ArrayIter cljs.core/SeqIter}, :variadic false, :max-fixed-arity 1}), :line 3113, :end-line 3113, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, mk-bound-fn {:protocol-inline nil, :name cljs.core/mk-bound-fn, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 3}), :line 7759, :end-line 7759, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key])), :test true}, last {:protocol-inline nil, :name cljs.core/last, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1168, :end-line 1168, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time", :test true}, pr {:protocol-inline nil, :name cljs.core/pr, :variadic true, :file "out/cljs/core.cljs", :end-column 10, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8277, :end-line 8277, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :test true}, tree-map-seq-push {:protocol-inline nil, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 6456, :end-line 6456, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?])), :test true}, namespace {:protocol-inline nil, :name cljs.core/namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 1}), :line 2529, :end-line 2529, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :test true}, empty-unordered-hash {:file "out/cljs/core.cljs", :line 847, :column 1, :end-line 847, :end-column 37, :private true, :test true, :name cljs.core/empty-unordered-hash}, obj-map {:protocol-inline nil, :name cljs.core/obj-map, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7141, :end-line 7141, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :test true}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 890, :record false, :end-line 890, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 264, :ret-tag clj, :end-line 265, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :test true}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6084, :record false, :end-line 6084, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :name cljs.core/=, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 758, :ret-tag boolean, :end-line 758, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :test true}, ITransientMap {:protocol-symbol true, :name cljs.core/ITransientMap, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 383, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 383, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :test true}, push-tail {:protocol-inline nil, :private true, :name cljs.core/push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 4}), :line 4183, :end-line 4183, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode])), :test true}, take {:protocol-inline nil, :name cljs.core/take, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3779, :end-line 3779, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :test true}, vector? {:protocol-inline nil, :name cljs.core/vector?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1537, :ret-tag boolean, :end-line 1537, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector", :test true}, bitmap-indexed-node-index {:protocol-inline nil, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5616, :end-line 5616, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit])), :test true}, boolean {:protocol-inline nil, :name cljs.core/boolean, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1604, :ret-tag boolean, :end-line 1604, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, IChunk {:protocol-symbol true, :name cljs.core/IChunk, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 396, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 396, :impls #{cljs.core/ArrayChunk}, :test true}, bit-shift-left {:protocol-inline nil, :name cljs.core/bit-shift-left, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2131, :end-line 2131, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left", :test true}, rand-int {:protocol-inline nil, :name cljs.core/rand-int, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8729, :end-line 8729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :test true}, aclone {:protocol-inline nil, :name cljs.core/aclone, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 169, :end-line 169, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array", :test true}, BlackNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6622, :record false, :declared true, :end-line 6622, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, vreset! {:protocol-inline nil, :name cljs.core/vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 3613, :end-line 3613, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :test true}, chunk {:protocol-inline nil, :name cljs.core/chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2740, :end-line 2740, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b])), :test true}, dec {:protocol-inline nil, :name cljs.core/dec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1917, :end-line 1917, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num.", :test true}, map {:protocol-inline nil, :name cljs.core/map, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 4}), :line 3732, :end-line 3732, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :test true}, juxt {:protocol-inline nil, :name cljs.core/juxt, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f g] [f g h] [f g h fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 7993, :end-line 7993, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :test true}, < {:protocol-inline nil, :name cljs.core/<, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1869, :ret-tag boolean, :end-line 1869, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :test true}, inode-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 5633, :end-line 5633, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init])), :test true}, obj-map->hash-map {:protocol-inline nil, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5022, :end-line 5022, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, test {:protocol-inline nil, :name cljs.core/test, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 1}), :line 9237, :end-line 9237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :test true}, rest {:protocol-inline nil, :name cljs.core/rest, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 736, :ret-tag seq, :end-line 736, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :test true}, ex-data {:protocol-inline nil, :name cljs.core/ex-data, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9200, :end-line 9200, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :test true}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5259, :record false, :end-line 5259, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 396, :end-line 397, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, isa? {:protocol-inline nil, :name cljs.core/isa?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic false, :max-fixed-arity 3}), :line 8766, :ret-tag boolean, :end-line 8766, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :test true}, -clone {:protocol-inline nil, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 255, :ret-tag clj, :end-line 256, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :test true}, empty-ordered-hash {:file "out/cljs/core.cljs", :line 832, :column 1, :end-line 832, :end-column 35, :private true, :test true, :name cljs.core/empty-ordered-hash}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 791, :record false, :end-line 791, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NeverEquiv, :variadic false, :max-fixed-arity 0}), :line 4977, :end-line 4977, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}, :test true}, re-seq {:protocol-inline nil, :name cljs.core/re-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8087, :end-line 8087, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s.", :test true}, make-hierarchy {:protocol-inline nil, :name cljs.core/make-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 8752, :end-line 8752, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc.", :test true}, Symbol {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 592, :record false, :declared true, :end-line 592, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, tv-push-tail {:protocol-inline nil, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 4}), :line 4704, :end-line 4704, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node])), :test true}, -reduce {:protocol-inline nil, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 320, :end-line 321, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f] [coll f start])), :test true}, -count {:protocol-inline nil, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 258, :ret-tag number, :end-line 259, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :test true}, keep {:protocol-inline nil, :name cljs.core/keep, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3453, :end-line 3453, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :test true}, char {:protocol-inline nil, :name cljs.core/char, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 1937, :end-line 1937, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char", :test true}, mapcat {:protocol-inline nil, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([f] [f colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 3947, :end-line 3947, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :test true}, unchecked-long {:protocol-inline nil, :name cljs.core/unchecked-long, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2047, :end-line 2047, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, m3-seed {:file "out/cljs/core.cljs", :line 464, :column 1, :end-line 464, :end-column 14, :test true, :name cljs.core/m3-seed}, some? {:protocol-inline nil, :name cljs.core/some?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 100, :ret-tag boolean, :end-line 100, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise.", :test true}, unchecked-negate {:protocol-inline nil, :name cljs.core/unchecked-negate, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2002, :end-line 2002, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, reverse {:protocol-inline nil, :name cljs.core/reverse, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq any}, :variadic false, :max-fixed-arity 1}), :line 2393, :end-line 2393, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :test true}, range {:protocol-inline nil, :name cljs.core/range, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 0} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 3}), :line 7896, :end-line 7896, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :test true}, bit-count {:protocol-inline nil, :name cljs.core/bit-count, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2147, :end-line 2147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n", :test true}, t7636 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7636, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3059, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, create-node {:protocol-inline nil, :private true, :name cljs.core/create-node, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 6} {:tag #{any cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 7}), :line 6066, :end-line 6066, :max-fixed-arity 7, :fn-var true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :test true}, sort {:protocol-inline nil, :name cljs.core/sort, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2}), :line 1707, :end-line 1707, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :test true}, ->MetaFn {:protocol-inline nil, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MetaFn, :variadic false, :max-fixed-arity 2}), :line 1396, :end-line 1396, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :test true}, unchecked-inc-int {:protocol-inline nil, :name cljs.core/unchecked-inc-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1985, :end-line 1985, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -compare {:protocol-inline nil, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 393, :ret-tag number, :end-line 394, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :test true}, map-indexed {:protocol-inline nil, :name cljs.core/map-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3426, :end-line 3426, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :test true}, array-list {:protocol-inline nil, :name cljs.core/array-list, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 0}), :line 7706, :end-line 7706, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, rand-nth {:protocol-inline nil, :name cljs.core/rand-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8733, :end-line 8733, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :test true}, comp {:protocol-inline nil, :name cljs.core/comp, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [f] [f g] [f g h] [f1 f2 f3 fs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3343, :end-line 3343, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :test true}, array-chunk {:protocol-inline nil, :name cljs.core/array-chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 1} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2660, :end-line 2660, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr] [arr off] [arr off end])), :test true}, bit-shift-right-zero-fill {:protocol-inline nil, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2139, :end-line 2139, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill", :test true}, -as-transient {:protocol-inline nil, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 373, :ret-tag clj, :end-line 374, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, dorun {:protocol-inline nil, :name cljs.core/dorun, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1} {:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8029, :end-line 8029, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :test true}, pr-sequential-writer {:protocol-inline nil, :name cljs.core/pr-sequential-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 7}), :line 8106, :end-line 8106, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll])), :test true}, accumulating-seq-count {:protocol-inline nil, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1201, :end-line 1201, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IIndexed {:protocol-symbol true, :name cljs.core/IIndexed, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 270, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 270, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :test true}, disj {:protocol-inline nil, :name cljs.core/disj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1480, :end-line 1480, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, IPrintWithWriter {:protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 357, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 357, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, ->UUID {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/->UUID, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([uuid]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/UUID, :variadic false, :max-fixed-arity 1}), :line 9146, :end-line 9146, :max-fixed-arity 1, :fn-var true, :arglists (quote ([uuid])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}, :test true}, IVector {:protocol-symbol true, :name cljs.core/IVector, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 305, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 305, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :test true}, IIterable {:protocol-symbol true, :name cljs.core/IIterable, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 421, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 421, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}, :test true}, *2 {:file "out/cljs/core.cljs", :line 63, :column 1, :end-line 65, :end-column 6, :doc "bound in a repl thread to the second most recent value printed", :test true, :name cljs.core/*2}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8593, :record false, :end-line 8593, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4164, :end-line 4164, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, cons {:protocol-inline nil, :name cljs.core/cons, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 2464, :end-line 2464, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest.", :test true}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7483, :record false, :end-line 7483, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, floats {:protocol-inline nil, :name cljs.core/floats, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2057, :end-line 2057, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, TransientVector {:num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4746, :record false, :declared true, :end-line 4746, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, pos? {:protocol-inline nil, :name cljs.core/pos?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2167, :ret-tag boolean, :end-line 2167, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false", :test true}, fnil {:protocol-inline nil, :name cljs.core/fnil, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4}), :line 3401, :end-line 3401, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :test true}, merge-with {:protocol-inline nil, :name cljs.core/merge-with, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 1}), :line 7317, :end-line 7317, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :test true}, nthrest {:protocol-inline nil, :name cljs.core/nthrest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1312, :end-line 1312, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0.", :test true}, sequential? {:protocol-inline nil, :name cljs.core/sequential?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1518, :ret-tag boolean, :end-line 1518, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential", :test true}, tree-map-replace {:protocol-inline nil, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 6967, :end-line 6967, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v])), :test true}, m3-mix-H1 {:protocol-inline nil, :name cljs.core/m3-mix-H1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 471, :ret-tag number, :end-line 471, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1])), :test true}, ->TransientArrayMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientArrayMap, :variadic false, :max-fixed-arity 3}), :line 5509, :end-line 5509, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, prim-seq {:protocol-inline nil, :name cljs.core/prim-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1073, :end-line 1073, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prim] [prim i])), :test true}, *print-level* {:file "out/cljs/core.cljs", :line 38, :column 1, :end-line 38, :end-column 30, :dynamic true, :test true, :name cljs.core/*print-level*}, shuffle {:protocol-inline nil, :name cljs.core/shuffle, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1748, :end-line 1748, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll", :test true}, ChunkedSeq {:num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4489, :record false, :declared true, :end-line 4489, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, hash-keyword {:protocol-inline nil, :name cljs.core/hash-keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2475, :end-line 2475, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, find {:protocol-inline nil, :name cljs.core/find, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1629, :end-line 1629, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present.", :test true}, alength {:protocol-inline nil, :name cljs.core/alength, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 206, :ret-tag number, :end-line 206, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types.", :test true}, bit-xor {:protocol-inline nil, :name cljs.core/bit-xor, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2083, :end-line 2083, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :test true}, ->IndexedSeq {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeq, :variadic false, :max-fixed-arity 2}), :line 1003, :end-line 1003, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :test true}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 5046, :record false, :end-line 5046, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2143, :end-line 2143, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill", :test true}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5170, :record false, :end-line 5170, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :name cljs.core/neg?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2174, :ret-tag boolean, :end-line 2174, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false", :test true}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2415, :record false, :end-line 2415, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8918, :end-line 8921, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :test true}, ->StringIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 2}), :line 3065, :end-line 3065, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil, :test true}, js-invoke {:protocol-inline nil, :name cljs.core/js-invoke, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj s args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 2}), :line 219, :end-line 219, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :test true}, ->List {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/List, :variadic false, :max-fixed-arity 5}), :line 2270, :end-line 2270, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, m3-mix-K1 {:protocol-inline nil, :name cljs.core/m3-mix-K1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 468, :ret-tag number, :end-line 468, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1])), :test true}, unchecked-float {:protocol-inline nil, :name cljs.core/unchecked-float, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1952, :ret-tag number, :end-line 1952, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, undefined? {:protocol-inline nil, :name cljs.core/undefined?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1589, :ret-tag boolean, :end-line 1589, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, IMeta {:protocol-symbol true, :name cljs.core/IMeta, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 314, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 314, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t7633 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/t7636 cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, reduced? {:protocol-inline nil, :name cljs.core/reduced?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 899, :ret-tag boolean, :end-line 899, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced", :test true}, apply-to {:protocol-inline nil, :name cljs.core/apply-to, :variadic false, :file "out/cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 2979, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args])), :test true}, disj! {:protocol-inline nil, :name cljs.core/disj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2964, :end-line 2964, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :test true}, -lookup {:protocol-inline nil, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 282, :end-line 283, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :test true}, ICloneable {:protocol-symbol true, :name cljs.core/ICloneable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 255, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 255, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :test true}, IEncodeClojure {:protocol-symbol true, :name cljs.core/IEncodeClojure, :file "out/cljs/core.cljs", :end-column 29, :column 1, :line 8659, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 8659, :impls #{}, :test true}, booleans {:protocol-inline nil, :name cljs.core/booleans, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2052, :end-line 2052, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, array-map-index-of-symbol? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5203, :end-line 5203, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ->ArrayList {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 1}), :line 7698, :end-line 7698, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil, :test true}, RSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 1088, :record false, :declared true, :end-line 1088, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, mask {:protocol-inline nil, :private true, :name cljs.core/mask, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5598, :end-line 5598, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, int-array {:protocol-inline nil, :name cljs.core/int-array, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2777, :end-line 2777, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, find-and-cache-best-method {:protocol-inline nil, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 7}), :line 8893, :end-line 8893, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :test true}, set? {:protocol-inline nil, :name cljs.core/set?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1507, :ret-tag boolean, :end-line 1507, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet", :test true}, iterable? {:protocol-inline nil, :name cljs.core/iterable?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 693, :end-line 693, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, cat {:protocol-inline nil, :added "1.7", :name cljs.core/cat, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8554, :end-line 8554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :test true}, ->ES6EntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5157, :end-line 5157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil, :test true}, divide {:file "out/cljs/core.cljs", :line 1860, :column 1, :end-line 1860, :end-column 17, :declared true, :test true, :name cljs.core/divide}, -pr-writer {:protocol-inline nil, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 357, :end-line 363, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :test true}, flush {:protocol-inline nil, :name cljs.core/flush, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 0}), :line 8133, :end-line 8133, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, set-from-indexed-seq {:protocol-inline nil, :name cljs.core/set-from-indexed-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7576, :end-line 7576, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq])), :test true}, take-while {:protocol-inline nil, :name cljs.core/take-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7740, :end-line 7740, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, vary-meta {:protocol-inline nil, :name cljs.core/vary-meta, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 5} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 6} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 6}), :line 3031, :end-line 3031, :max-fixed-arity 6, :fn-var true, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :test true}, INext {:protocol-symbol true, :name cljs.core/INext, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 279, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 279, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :test true}, is_proto_ {:protocol-inline nil, :name cljs.core/is_proto_, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 123, :end-line 123, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, START {:file "out/cljs/core.cljs", :line 3090, :column 1, :end-line 3090, :end-column 12, :test true, :name cljs.core/START}, ICounted {:protocol-symbol true, :name cljs.core/ICounted, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 258, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 258, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, IMapEntry {:protocol-symbol true, :name cljs.core/IMapEntry, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 294, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 294, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :test true}, <= {:protocol-inline nil, :name cljs.core/<=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1881, :ret-tag boolean, :end-line 1881, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :test true}, conj! {:protocol-inline nil, :name cljs.core/conj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [coll] [tcoll val] [tcoll val vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2923, :end-line 2923, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :test true}, -pop {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 301, :ret-tag clj, :end-line 303, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, repeatedly {:protocol-inline nil, :name cljs.core/repeatedly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3886, :end-line 3886, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :test true}, zipmap {:protocol-inline nil, :name cljs.core/zipmap, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 7672, :end-line 7672, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals.", :test true}, IStack {:protocol-symbol true, :name cljs.core/IStack, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 301, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 301, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :test true}, -remove-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 368, :end-line 371, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :test true}, IVolatile {:protocol-symbol true, :name cljs.core/IVolatile, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 418, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 418, :impls #{cljs.core/Volatile}, :test true}, remove {:protocol-inline nil, :name cljs.core/remove, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3986, :end-line 3986, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->BitmapIndexedNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5651, :end-line 5651, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil, :test true}, * {:protocol-inline nil, :name cljs.core/*, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1853, :ret-tag number, :end-line 1853, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, re-pattern {:protocol-inline nil, :name cljs.core/re-pattern, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil js/RegExp}, :variadic false, :max-fixed-arity 1}), :line 8096, :end-line 8096, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string.", :test true}, min {:protocol-inline nil, :name cljs.core/min, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1928, :ret-tag number, :end-line 1928, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :test true}, array-map-index-of-nil? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5184, :end-line 5184, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -persistent! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 376, :ret-tag clj, :end-line 378, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :test true}, -nth {:protocol-inline nil, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3}), :line 270, :end-line 271, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :test true}, pop! {:protocol-inline nil, :name cljs.core/pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2958, :end-line 2958, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :test true}, chunk-append {:protocol-inline nil, :name cljs.core/chunk-append, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 2737, :end-line 2737, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x])), :test true}, prn-str {:protocol-inline nil, :name cljs.core/prn-str, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8272, :end-line 8272, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :test true}, IReversible {:protocol-symbol true, :name cljs.core/IReversible, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 344, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 344, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :test true}, reversible? {:protocol-inline nil, :name cljs.core/reversible?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2387, :ret-tag boolean, :end-line 2387, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :test true}, -realized? {:protocol-inline nil, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 365, :ret-tag boolean, :end-line 366, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :test true}, -add-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 368, :end-line 370, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :test true}, -deref-with-timeout {:protocol-inline nil, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 311, :end-line 312, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :test true}, conj {:protocol-inline nil, :name cljs.core/conj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [coll] [coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 1180, :end-line 1180, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :test true}, -sorted-seq {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 347, :ret-tag clj, :end-line 348, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :test true}, flatten1 {:protocol-inline nil, :private true, :name cljs.core/flatten1, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3933, :end-line 3933, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :test true}, transduce {:protocol-inline nil, :name cljs.core/transduce, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4}), :line 1820, :end-line 1820, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :test true}, fixture1 {:file "out/cljs/core.cljs", :line 8514, :column 1, :end-line 8514, :end-column 15, :test true, :name cljs.core/fixture1}, -swap! {:protocol-inline nil, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5}), :line 415, :end-line 416, :max-fixed-arity 5, :fn-var true, :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :test true}, *print-length* {:file "out/cljs/core.cljs", :line 37, :column 1, :end-line 37, :end-column 31, :dynamic true, :test true, :name cljs.core/*print-length*}, js-delete {:protocol-inline nil, :name cljs.core/js-delete, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1558, :end-line 1558, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :test true}, truth_ {:protocol-inline nil, :name cljs.core/truth_, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 71, :end-line 71, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!", :test true}, ->MultiFn {:protocol-inline nil, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiFn, :variadic false, :max-fixed-arity 8}), :line 8930, :end-line 8930, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :test true}, key->js {:protocol-inline nil, :name cljs.core/key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any string}, :variadic false, :max-fixed-arity 1}), :line 8628, :end-line 8628, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ->MultiStepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/MultiStepper, :variadic false, :max-fixed-arity 3}), :line 3156, :end-line 3156, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil, :test true}, IEncodeJS {:protocol-symbol true, :name cljs.core/IEncodeJS, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 8621, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 8621, :impls #{}, :test true}, new-path {:protocol-inline nil, :private true, :name cljs.core/new-path, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4173, :end-line 4173, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node])), :test true}, compare-and-set! {:protocol-inline nil, :name cljs.core/compare-and-set!, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 3}), :line 3572, :end-line 3572, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :test true}, array-seq {:protocol-inline nil, :name cljs.core/array-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1080, :end-line 1080, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array] [array i])), :test true}, array-copy-downward {:protocol-inline nil, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1569, :end-line 1569, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, pack-array-node {:protocol-inline nil, :private true, :name cljs.core/pack-array-node, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5849, :end-line 5849, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx])), :test true}, interleave {:protocol-inline nil, :name cljs.core/interleave, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([c1 c2] [c1 c2 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 3898, :end-line 3898, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :test true}, print-map {:protocol-inline nil, :name cljs.core/print-map, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 8316, :end-line 8316, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts])), :test true}, map? {:protocol-inline nil, :name cljs.core/map?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1530, :ret-tag boolean, :end-line 1530, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap", :test true}, m3-C1 {:file "out/cljs/core.cljs", :line 465, :column 1, :end-line 465, :end-column 12, :test true, :name cljs.core/m3-C1}, get {:protocol-inline nil, :name cljs.core/get, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1320, :end-line 1320, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :test true}, identity {:protocol-inline nil, :name cljs.core/identity, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1810, :end-line 1810, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, into {:protocol-inline nil, :name cljs.core/into, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4017, :end-line 4017, :max-fixed-arity 3, :fn-var true, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :test true}, long {:protocol-inline nil, :name cljs.core/long, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2042, :end-line 2042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'.", :test true}, double {:protocol-inline nil, :name cljs.core/double, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1947, :ret-tag number, :end-line 1947, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, volatile? {:protocol-inline nil, :name cljs.core/volatile?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3609, :end-line 3609, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile.", :test true}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2619, :record false, :end-line 2619, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 294, :end-line 295, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, nfirst {:protocol-inline nil, :name cljs.core/nfirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1153, :end-line 1153, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))", :test true}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 426, :record false, :end-line 426, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :name cljs.core/meta, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1458, :end-line 1458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata.", :test true}, tv-editable-tail {:protocol-inline nil, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 4699, :end-line 4699, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl])), :test true}, -kv-reduce {:protocol-inline nil, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 323, :end-line 324, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :test true}, IHash {:protocol-symbol true, :name cljs.core/IHash, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 329, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 329, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, bit-and-not {:protocol-inline nil, :name cljs.core/bit-and-not, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2101, :end-line 2101, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :test true}, -comparator {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 347, :end-line 351, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, unchecked-add-int {:protocol-inline nil, :name cljs.core/unchecked-add-int, :variadic true, :file "out/cljs/core.cljs", :end-column 33, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1962, :ret-tag number, :end-line 1962, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, hash-ordered-coll {:protocol-inline nil, :name cljs.core/hash-ordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 821, :ret-tag number, :end-line 821, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, extend-object! {:protocol-inline nil, :private true, :name cljs.core/extend-object!, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 2258, :end-line 2258, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :test true}, do-assoc {:protocol-inline nil, :private true, :name cljs.core/do-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 5}), :line 4226, :end-line 4226, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val])), :test true}, reset-meta! {:protocol-inline nil, :name cljs.core/reset-meta!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8460, :end-line 8460, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom", :test true}, ->KeySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/KeySeq, :variadic false, :max-fixed-arity 2}), :line 7173, :end-line 7173, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, IEquiv {:protocol-symbol true, :name cljs.core/IEquiv, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 326, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 326, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, tree-map-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 6606, :end-line 6606, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init])), :test true}, cycle {:protocol-inline nil, :name cljs.core/cycle, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3866, :end-line 3866, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :test true}, -deref {:protocol-inline nil, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 308, :end-line 309, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, pr-writer-ex-info {:protocol-inline nil, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9168, :end-line 9168, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :test true}, empty? {:protocol-inline nil, :name cljs.core/empty?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1494, :ret-tag boolean, :end-line 1494, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :test true}, short {:protocol-inline nil, :name cljs.core/short, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1945, :ret-tag number, :end-line 1945, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, -clj->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8621, :end-line 8622, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -chunked-first {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 399, :end-line 400, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, filterv {:protocol-inline nil, :name cljs.core/filterv, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 4047, :end-line 4047, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :test true}, tv-editable-root {:protocol-inline nil, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4696, :end-line 4696, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node])), :test true}, hash {:protocol-inline nil, :name cljs.core/hash, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 539, :end-line 539, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, quot {:protocol-inline nil, :name cljs.core/quot, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2071, :end-line 2071, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator.", :test true}, unchecked-double {:protocol-inline nil, :name cljs.core/unchecked-double, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1953, :ret-tag number, :end-line 1953, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ->ChunkedCons {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedCons, :variadic false, :max-fixed-arity 4}), :line 2668, :end-line 2668, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, ranged-iterator {:protocol-inline nil, :name cljs.core/ranged-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 3}), :line 4262, :end-line 4262, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end])), :test true}, ITransientVector {:protocol-symbol true, :name cljs.core/ITransientVector, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 386, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 386, :impls #{cljs.core/TransientVector}, :test true}, key {:protocol-inline nil, :name cljs.core/key, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7236, :end-line 7236, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry.", :test true}, longs {:protocol-inline nil, :name cljs.core/longs, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2059, :end-line 2059, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, not= {:protocol-inline nil, :name cljs.core/not=, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 3047, :ret-tag boolean, :end-line 3047, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :test true}, string? {:protocol-inline nil, :name cljs.core/string?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 109, :ret-tag boolean, :end-line 109, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, es6-iterator {:protocol-inline nil, :name cljs.core/es6-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 786, :end-line 786, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8519, :record false, :end-line 8519, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, pr-str-with-opts {:protocol-inline nil, :name cljs.core/pr-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8239, :end-line 8239, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :test true}, m3-C2 {:file "out/cljs/core.cljs", :line 466, :column 1, :end-line 466, :end-column 12, :test true, :name cljs.core/m3-C2}, ->Symbol {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 5}), :line 592, :end-line 592, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :test true}, *print-newline* {:file "out/cljs/core.cljs", :line 33, :column 1, :end-line 33, :end-column 32, :dynamic true, :test true, :name cljs.core/*print-newline*}, unchecked-multiply-int {:protocol-inline nil, :name cljs.core/unchecked-multiply-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1995, :ret-tag number, :end-line 1995, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, chunk-rest {:protocol-inline nil, :name cljs.core/chunk-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2746, :end-line 2746, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, remove-all-methods {:protocol-inline nil, :name cljs.core/remove-all-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9115, :end-line 9115, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod.", :test true}, trampoline {:protocol-inline nil, :name cljs.core/trampoline, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 8707, :end-line 8707, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :test true}, pr-opts {:protocol-inline nil, :private true, :name cljs.core/pr-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 42, :end-line 42, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, *1 {:file "out/cljs/core.cljs", :line 59, :column 1, :end-line 61, :end-column 6, :doc "bound in a repl thread to the most recent value printed", :test true, :name cljs.core/*1}, vec {:protocol-inline nil, :name cljs.core/vec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any}, :variadic false, :max-fixed-arity 1}), :line 4474, :end-line 4474, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, *print-meta* {:file "out/cljs/core.cljs", :line 35, :column 1, :end-line 35, :end-column 29, :dynamic true, :test true, :name cljs.core/*print-meta*}, -notify-watches {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 368, :end-line 369, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :test true}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 8930, :record false, :end-line 8930, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :name cljs.core/int, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2032, :end-line 2032, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, ->ValSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ValSeq, :variadic false, :max-fixed-arity 2}), :line 7241, :end-line 7241, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, rand {:protocol-inline nil, :name cljs.core/rand, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:tag number, :variadic false, :max-fixed-arity 1}), :line 8723, :end-line 8723, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :test true}, second {:protocol-inline nil, :name cljs.core/second, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1143, :end-line 1143, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IEditableCollection {:protocol-symbol true, :name cljs.core/IEditableCollection, :file "out/cljs/core.cljs", :end-column 34, :column 1, :line 373, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 373, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :test true}, t7633 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7633, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3059, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, hash-combine {:protocol-inline nil, :name cljs.core/hash-combine, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 562, :end-line 562, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash])), :test true}, > {:protocol-inline nil, :name cljs.core/>, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1893, :ret-tag boolean, :end-line 1893, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :test true}, -name {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 406, :ret-tag string, :end-line 407, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :test true}, replace {:protocol-inline nil, :name cljs.core/replace, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag #{nil any cljs.core/LazySeq}, :variadic false, :max-fixed-arity 2}), :line 7615, :end-line 7615, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :test true}, ->Subvec {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4573, :end-line 4573, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, associative? {:protocol-inline nil, :name cljs.core/associative?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1514, :ret-tag boolean, :end-line 1514, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative", :test true}, unchecked-int {:protocol-inline nil, :name cljs.core/unchecked-int, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2037, :end-line 2037, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places.", :test true}, js-keys {:protocol-inline nil, :name cljs.core/js-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 1553, :end-line 1553, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :test true}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5157, :record false, :end-line 5157, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :name cljs.core/keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2518, :ret-tag boolean, :end-line 2518, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, array-iter {:protocol-inline nil, :name cljs.core/array-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 1}), :line 3086, :end-line 3086, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, force {:protocol-inline nil, :name cljs.core/force, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8535, :end-line 8535, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :test true}, group-by {:protocol-inline nil, :name cljs.core/group-by, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 8740, :end-line 8740, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :test true}, -rseq {:protocol-inline nil, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 344, :ret-tag clj, :end-line 345, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, prn {:protocol-inline nil, :name cljs.core/prn, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8309, :end-line 8309, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :test true}, tv-pop-tail {:protocol-inline nil, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4716, :end-line 4716, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node])), :test true}, ->Atom {:protocol-inline nil, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Atom, :variadic false, :max-fixed-arity 4}), :line 3487, :end-line 3487, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :test true}, PersistentHashMap {:num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6202, :record false, :declared true, :end-line 6202, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, unchecked-multiply {:protocol-inline nil, :name cljs.core/unchecked-multiply, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1988, :ret-tag number, :end-line 1988, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :test true}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 6147, :record false, :end-line 6147, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :name cljs.core/even?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3319, :ret-tag boolean, :end-line 3319, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer", :test true}, es6-iterator-seq {:protocol-inline nil, :name cljs.core/es6-iterator-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 801, :end-line 801, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :test true}, unchecked-dec {:protocol-inline nil, :name cljs.core/unchecked-dec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1969, :end-line 1969, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, hash-collision-node-find-index {:protocol-inline nil, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5959, :end-line 5959, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key])), :test true}, persistent-array-map-seq {:protocol-inline nil, :name cljs.core/persistent-array-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/PersistentArrayMapSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5314, :end-line 5314, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :test true}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 7795, :record false, :end-line 7795, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 3156, :record false, :end-line 3156, :skip-protocol-flag nil}, double-array {:protocol-inline nil, :name cljs.core/double-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2817, :end-line 2817, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, ->EmptyList {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/EmptyList, :variadic false, :max-fixed-arity 1}), :line 2331, :end-line 2331, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, seq-reduce {:protocol-inline nil, :private true, :name cljs.core/seq-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1732, :end-line 1732, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :test true}, spread {:protocol-inline nil, :name cljs.core/spread, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 2865, :end-line 2865, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist])), :test true}, balance-left {:protocol-inline nil, :private true, :name cljs.core/balance-left, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6521, :end-line 6521, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right])), :test true}, rseq {:protocol-inline nil, :name cljs.core/rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2390, :ret-tag seq, :end-line 2390, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :test true}, ex-cause {:protocol-inline nil, :name cljs.core/ex-cause, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9216, :end-line 9216, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :test true}, IReset {:protocol-symbol true, :name cljs.core/IReset, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 412, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 412, :impls #{}, :test true}, IEmptyableCollection {:protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 261, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 261, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, array-map-index-of {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5230, :end-line 5230, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, ex-message {:protocol-inline nil, :name cljs.core/ex-message, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9208, :end-line 9208, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :test true}, string-print {:protocol-inline nil, :name cljs.core/string-print, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8129, :end-line 8129, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, float {:protocol-inline nil, :name cljs.core/float, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1946, :ret-tag number, :end-line 1946, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, fixture2 {:file "out/cljs/core.cljs", :line 8515, :column 1, :end-line 8515, :end-column 15, :test true, :name cljs.core/fixture2}, IRecord {:protocol-symbol true, :name cljs.core/IRecord, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 341, :protocol-info {:methods {}}, :info nil, :end-line 341, :impls #{}, :test true}, pr-str {:protocol-inline nil, :name cljs.core/pr-str, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8267, :end-line 8267, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :test true}, first-array-for-longvec {:protocol-inline nil, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 4202, :end-line 4202, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv])), :test true}, es6-set-entries-iterator {:protocol-inline nil, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5179, :end-line 5179, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, concat {:protocol-inline nil, :name cljs.core/concat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [x] [x y] [x y zs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 2873, :end-line 2873, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :test true}, -methods {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8918, :end-line 8924, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, IDerefWithTimeout {:protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "out/cljs/core.cljs", :end-column 32, :column 1, :line 311, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 311, :impls #{}, :test true}, symbol {:protocol-inline nil, :name cljs.core/symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 2}), :line 626, :end-line 626, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :test true}, to-array-2d {:protocol-inline nil, :name cljs.core/to-array-2d, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2766, :end-line 2766, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :test true}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4573, :record false, :end-line 4573, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:num-fields 3, :protocols #{}, :name cljs.core/ExceptionInfo, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 9166, :record false, :end-line 9166, :skip-protocol-flag nil}, mod {:protocol-inline nil, :name cljs.core/mod, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2066, :end-line 2066, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity.", :test true}, ISet {:protocol-symbol true, :name cljs.core/ISet, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 298, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 298, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :test true}, pop {:protocol-inline nil, :name cljs.core/pop, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1472, :end-line 1472, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :test true}, IPending {:protocol-symbol true, :name cljs.core/IPending, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 365, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 365, :impls #{cljs.core/Delay}, :test true}, -entry-key {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 347, :end-line 350, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :test true}, pop-tail {:protocol-inline nil, :private true, :name cljs.core/pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4236, :end-line 4236, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node])), :test true}, dissoc! {:protocol-inline nil, :name cljs.core/dissoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll key] [tcoll key ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2948, :end-line 2948, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :test true}, reductions {:protocol-inline nil, :name cljs.core/reductions, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3}), :line 7979, :end-line 7979, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :test true}, indexed? {:protocol-inline nil, :name cljs.core/indexed?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 990, :ret-tag boolean, :end-line 990, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time", :test true}, - {:protocol-inline nil, :name cljs.core/-, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1846, :ret-tag number, :end-line 1846, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, -equiv {:protocol-inline nil, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 326, :ret-tag boolean, :end-line 327, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :test true}, ->RangeIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangeIterator, :variadic false, :max-fixed-arity 3}), :line 7795, :end-line 7795, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil, :test true}, ->ArrayNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNode, :variadic false, :max-fixed-arity 3}), :line 5862, :end-line 5862, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil, :test true}, assoc! {:protocol-inline nil, :name cljs.core/assoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tcoll key val] [tcoll key val kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 2936, :end-line 2936, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :test true}, hash-set {:protocol-inline nil, :name cljs.core/hash-set, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([] [keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ISet, :variadic false, :max-fixed-arity 0} {:tag clj, :variadic true, :max-fixed-arity 0}), :line 7599, :end-line 7599, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keys])), :test true}, reduce-kv {:protocol-inline nil, :name cljs.core/reduce-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1798, :end-line 1798, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :test true}, reset! {:file "out/cljs/core.cljs", :line 5590, :column 1, :end-line 5590, :end-column 56, :declared true, :test true, :name cljs.core/reset!}, name {:protocol-inline nil, :name cljs.core/name, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 1}), :line 7663, :end-line 7663, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword.", :test true}, ->RedNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RedNode, :variadic false, :max-fixed-arity 5}), :line 6726, :end-line 6726, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, unchecked-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4210, :end-line 4210, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, Fn {:protocol-symbol true, :name cljs.core/Fn, :file "out/cljs/core.cljs", :end-column 17, :column 1, :line 227, :protocol-info {:methods {}}, :info nil, :end-line 227, :impls #{cljs.core/Var function cljs.core/MetaFn}, :test true}, ffirst {:protocol-inline nil, :name cljs.core/ffirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1148, :end-line 1148, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))", :test true}, sorted-set {:protocol-inline nil, :name cljs.core/sorted-set, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 0}), :line 7603, :end-line 7603, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :test true}, pr-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8256, :end-line 8256, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :test true}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6976, :record false, :end-line 6976, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMap, :variadic false, :max-fixed-arity 5}), :line 6976, :end-line 6976, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, array-reduce {:protocol-inline nil, :private true, :name cljs.core/array-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 953, :end-line 953, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :test true}, counted? {:protocol-inline nil, :name cljs.core/counted?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 986, :ret-tag boolean, :end-line 986, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time", :test true}, println {:protocol-inline nil, :name cljs.core/println, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8297, :end-line 8297, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :test true}, assoc-in {:protocol-inline nil, :name cljs.core/assoc-in, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([m p__9192 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 4099, :end-line 4099, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :test true}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7351, :record false, :end-line 7351, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :name cljs.core/bit-test, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2126, :ret-tag boolean, :end-line 2126, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n", :test true}, TransientHashMap {:num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6351, :record false, :declared true, :end-line 6351, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->PersistentHashMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashMap, :variadic false, :max-fixed-arity 6}), :line 6202, :end-line 6202, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, ISwap {:protocol-symbol true, :name cljs.core/ISwap, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 415, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 415, :impls #{}, :test true}, ChunkedCons {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2668, :record false, :declared true, :end-line 2668, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :test true}, memoize {:protocol-inline nil, :name cljs.core/memoize, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8692, :end-line 8692, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :test true}, alter-meta! {:protocol-inline nil, :name cljs.core/alter-meta!, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic true, :max-fixed-arity 2}), :line 8451, :end-line 8451, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :test true}, ->StringBufferWriter {:protocol-inline nil, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/StringBufferWriter, :variadic false, :max-fixed-arity 1}), :line 426, :end-line 426, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}, :test true}, zero? {:protocol-inline nil, :name cljs.core/zero?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2171, :ret-tag boolean, :end-line 2171, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :test true}, tv-ensure-editable {:protocol-inline nil, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 2}), :line 4691, :end-line 4691, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node])), :test true}, *main-cli-fn* {:file "out/cljs/core.cljs", :line 127, :column 1, :end-line 131, :end-column 17, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :test true, :name cljs.core/*main-cli-fn*}, -assoc-n {:protocol-inline nil, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 305, :ret-tag clj, :end-line 306, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :test true}, unchecked-dec-int {:protocol-inline nil, :name cljs.core/unchecked-dec-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1972, :end-line 1972, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, hash-imap {:protocol-inline nil, :private true, :name cljs.core/hash-imap, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2237, :end-line 2237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, dominates {:protocol-inline nil, :private true, :name cljs.core/dominates, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8889, :end-line 8889, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, persistent! {:protocol-inline nil, :name cljs.core/persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2916, :end-line 2916, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :test true}, set-print-fn! {:protocol-inline nil, :name cljs.core/set-print-fn!, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 28, :end-line 28, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f.", :test true}, nnext {:protocol-inline nil, :name cljs.core/nnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1163, :end-line 1163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))", :test true}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 5588, :record false, :end-line 5588, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :private true, :name cljs.core/balance-right, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6546, :end-line 6546, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins])), :test true}, throw-no-method-error {:protocol-inline nil, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 8927, :end-line 8927, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val])), :test true}, add-watch {:protocol-inline nil, :name cljs.core/add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 8465, :end-line 8465, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :test true}, not-every? {:protocol-inline nil, :name cljs.core/not-every?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3300, :ret-tag boolean, :end-line 3300, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :test true}, rem {:protocol-inline nil, :name cljs.core/rem, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2077, :end-line 2077, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator.", :test true}, pr-sb-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag goog/string.StringBuffer, :variadic false, :max-fixed-arity 2}), :line 8232, :end-line 8232, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :test true}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5651, :record false, :end-line 5651, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/NodeSeq, :variadic false, :max-fixed-arity 5}), :line 6084, :end-line 6084, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, some {:protocol-inline nil, :name cljs.core/some, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 3305, :end-line 3305, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :test true}, INamed {:protocol-symbol true, :name cljs.core/INamed, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 406, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 406, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :test true}, ->Box {:protocol-inline nil, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Box, :variadic false, :max-fixed-arity 1}), :line 5588, :end-line 5588, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil, :test true}, IReduce {:protocol-symbol true, :name cljs.core/IReduce, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 320, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 320, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, drop {:protocol-inline nil, :name cljs.core/drop, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3804, :end-line 3804, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :test true}, js-obj {:protocol-inline nil, :name cljs.core/js-obj, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 0} {:tag any, :variadic true, :max-fixed-arity 0}), :line 1547, :end-line 1547, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keyvals])), :test true}, ITransientCollection {:protocol-symbol true, :name cljs.core/ITransientCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 376, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 376, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :test true}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 3487, :record false, :end-line 3487, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :name cljs.core/nth, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1248, :end-line 1248, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :test true}, sorted? {:protocol-inline nil, :name cljs.core/sorted?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1522, :ret-tag boolean, :end-line 1522, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted", :test true}, nil? {:protocol-inline nil, :name cljs.core/nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 85, :ret-tag boolean, :end-line 85, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise.", :test true}, split-at {:protocol-inline nil, :name cljs.core/split-at, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 3872, :end-line 3872, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]", :test true}, TransientHashSet {:num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7446, :record false, :declared true, :end-line 7446, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, array-map-extend-kv {:protocol-inline nil, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3}), :line 5245, :end-line 5245, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v])), :test true}, prn-str-with-opts {:protocol-inline nil, :name cljs.core/prn-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8247, :end-line 8247, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)", :test true}, not-native {:file "out/cljs/core.cljs", :line 76, :column 1, :end-line 76, :end-column 17, :test true, :name cljs.core/not-native}, random-sample {:protocol-inline nil, :name cljs.core/random-sample, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8585, :end-line 8585, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :test true}, select-keys {:protocol-inline nil, :name cljs.core/select-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7333, :end-line 7333, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys", :test true}, bit-and {:protocol-inline nil, :name cljs.core/bit-and, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2089, :end-line 2089, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :test true}, bounded-count {:protocol-inline nil, :private true, :name cljs.core/bounded-count, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2857, :end-line 2857, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n])), :test true}, update {:protocol-inline nil, :name cljs.core/update, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4135, :end-line 4135, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :test true}, gensym_counter {:file "out/cljs/core.cljs", :line 8500, :column 1, :end-line 8500, :end-column 21, :test true, :name cljs.core/gensym_counter}, list* {:protocol-inline nil, :name cljs.core/list*, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([args] [a args] [a b args] [a b c args] [a b c d more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4} {:tag cljs.core/Cons, :variadic true, :max-fixed-arity 4}), :line 2898, :end-line 2898, :max-fixed-arity 4, :fn-var true, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :test true}, ->Keyword {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 4}), :line 2490, :end-line 2490, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, update-in {:protocol-inline nil, :name cljs.core/update-in, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m p__9198 f] [m p__9199 f a] [m p__9200 f a b] [m p__9201 f a b c] [m p__9202 f a b c args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4108, :end-line 4108, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :test true}, prefer-method {:protocol-inline nil, :name cljs.core/prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 9125, :end-line 9125, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :test true}, hash-symbol {:protocol-inline nil, :private true, :name cljs.core/hash-symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 575, :end-line 575, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :test true}, ensure-reduced {:protocol-inline nil, :name cljs.core/ensure-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Reduced}, :variadic false, :max-fixed-arity 1}), :line 904, :end-line 904, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)", :test true}, edit-and-set {:protocol-inline nil, :private true, :name cljs.core/edit-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 6}), :line 5622, :end-line 5622, :max-fixed-arity 6, :fn-var true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :test true}, ->PersistentArrayMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMap, :variadic false, :max-fixed-arity 4}), :line 5329, :end-line 5329, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :test true}, instance? {:protocol-inline nil, :name cljs.core/instance?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([t o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 569, :ret-tag boolean, :end-line 569, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o])), :test true}, mix-collection-hash {:protocol-inline nil, :name cljs.core/mix-collection-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 809, :ret-tag number, :end-line 809, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, re-find {:protocol-inline nil, :name cljs.core/re-find, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8073, :end-line 8073, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :test true}, run! {:protocol-inline nil, :name cljs.core/run!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8615, :end-line 8615, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :test true}, char-escapes {:file "out/cljs/core.cljs", :line 8136, :column 1, :end-line 8136, :end-column 29, :private true, :test true, :name cljs.core/char-escapes}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 777, :record false, :end-line 777, :skip-protocol-flag nil}, val {:protocol-inline nil, :name cljs.core/val, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 7304, :end-line 7304, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry.", :test true}, unchecked-add {:protocol-inline nil, :name cljs.core/unchecked-add, :variadic true, :file "out/cljs/core.cljs", :end-column 29, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1955, :ret-tag number, :end-line 1955, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, not {:protocol-inline nil, :name cljs.core/not, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 96, :ret-tag boolean, :end-line 96, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise.", :test true}, -vreset! {:protocol-inline nil, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 418, :end-line 419, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :test true}, fn->comparator {:protocol-inline nil, :private true, :name cljs.core/fn->comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number function}, :variadic false, :max-fixed-arity 1}), :line 1691, :end-line 1691, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :test true}, with-meta {:protocol-inline nil, :name cljs.core/with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1449, :end-line 1449, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :test true}, unreduced {:protocol-inline nil, :name cljs.core/unreduced, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 909, :end-line 909, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x", :test true}, type {:protocol-inline nil, :name cljs.core/type, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 133, :end-line 133, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, identical? {:protocol-inline nil, :name cljs.core/identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 80, :ret-tag boolean, :end-line 80, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object", :test true}, -namespace {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 406, :ret-tag string, :end-line 408, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :test true}, unchecked-divide-int {:protocol-inline nil, :name cljs.core/unchecked-divide-int, :variadic true, :file "out/cljs/core.cljs", :end-column 36, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1975, :ret-tag number, :end-line 1975, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, swap-global-hierarchy! {:protocol-inline nil, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "out/cljs/core.cljs", :end-column 31, :method-params ([f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 1}), :line 8763, :end-line 8763, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & args])), :test true}, max-key {:protocol-inline nil, :name cljs.core/max-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7684, :end-line 7684, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :test true}, ->PersistentTreeSet {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeSet, :variadic false, :max-fixed-arity 3}), :line 7483, :end-line 7483, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :test true}, ->ChunkBuffer {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 2}), :line 2619, :end-line 2619, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}, :test true}, hash-string {:protocol-inline nil, :name cljs.core/hash-string, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 530, :end-line 530, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7241, :record false, :end-line 7241, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8918, :end-line 8925, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, set-validator! {:protocol-inline nil, :name cljs.core/set-validator!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3581, :end-line 3581, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :test true}, array-map-index-of-equiv? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-equiv?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5222, :end-line 5222, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, -meta {:protocol-inline nil, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 314, :ret-tag clj-or-nil, :end-line 315, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :test true}, RedNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6726, :record false, :declared true, :end-line 6726, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, ->IndexedSeqIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeqIterator, :variadic false, :max-fixed-arity 2}), :line 994, :end-line 994, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, -add-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 8918, :end-line 8920, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :test true}, balance-left-del {:protocol-inline nil, :private true, :name cljs.core/balance-left-del, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6568, :end-line 6568, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right])), :test true}, swap! {:protocol-inline nil, :name cljs.core/swap!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([a f] [a f x] [a f x y] [a f x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic true, :max-fixed-arity 4}), :line 3550, :end-line 3550, :max-fixed-arity 4, :fn-var true, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :test true}, vals {:protocol-inline nil, :name cljs.core/vals, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ValSeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7298, :end-line 7298, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values.", :test true}, -chunked-next {:protocol-inline nil, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 403, :end-line 404, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, unchecked-subtract {:protocol-inline nil, :name cljs.core/unchecked-subtract, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2013, :ret-tag number, :end-line 2013, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :test true}, remove-pair {:protocol-inline nil, :private true, :name cljs.core/remove-pair, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 2}), :line 5610, :end-line 5610, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :test true}, IMap {:protocol-symbol true, :name cljs.core/IMap, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 290, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 290, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :test true}, ->SeqIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 2}), :line 3092, :end-line 3092, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil, :test true}, sorted-set-by {:protocol-inline nil, :name cljs.core/sorted-set-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 7608, :end-line 7608, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :test true}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 4272, :record false, :end-line 4272, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :name cljs.core/cloneable?, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 699, :end-line 699, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :test true}, hash-string* {:protocol-inline nil, :name cljs.core/hash-string*, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 513, :end-line 513, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, key-test {:protocol-inline nil, :name cljs.core/key-test, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 5592, :ret-tag boolean, :end-line 5592, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other])), :test true}, ->LazyTransformer {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 4}), :line 3201, :end-line 3201, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, -reset {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8918, :end-line 8919, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :test true}, true? {:protocol-inline nil, :name cljs.core/true?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1585, :ret-tag boolean, :end-line 1585, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise.", :test true}, array {:protocol-inline nil, :name cljs.core/array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 178, :ret-tag array, :end-line 178, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args", :test true}, print {:protocol-inline nil, :name cljs.core/print, :variadic true, :file "out/cljs/core.cljs", :end-column 9, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8285, :end-line 8288, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :test true}, -peek {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 301, :end-line 302, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, ISeq {:protocol-symbol true, :name cljs.core/ISeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 275, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 275, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :test true}, empty {:protocol-inline nil, :name cljs.core/empty, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1195, :end-line 1195, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil", :test true}, remove-method {:protocol-inline nil, :name cljs.core/remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9120, :end-line 9120, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value.", :test true}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 4879, :record false, :end-line 4879, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :private true, :name cljs.core/balance-right-del, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6587, :end-line 6587, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del])), :test true}, volatile! {:protocol-inline nil, :name cljs.core/volatile!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3604, :end-line 3604, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val.", :test true}, / {:protocol-inline nil, :name cljs.core//, :variadic true, :file "out/cljs/core.cljs", :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1862, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :test true}, bitpos {:protocol-inline nil, :private true, :name cljs.core/bitpos, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5619, :end-line 5619, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift])), :test true}, bit-or {:protocol-inline nil, :name cljs.core/bit-or, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 2095, :end-line 2095, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :test true}, m3-fmix {:protocol-inline nil, :name cljs.core/m3-fmix, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 474, :ret-tag number, :end-line 474, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len])), :test true}, vector {:protocol-inline nil, :name cljs.core/vector, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any}, :variadic true, :max-fixed-arity 0}), :line 4482, :end-line 4482, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& args])), :test true}, hash-coll {:protocol-inline nil, :private true, :name cljs.core/hash-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 1}), :line 2227, :end-line 2227, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, clone-and-set {:protocol-inline nil, :private true, :name cljs.core/clone-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3} {:tag array, :variadic false, :max-fixed-arity 5}), :line 5601, :end-line 5601, :max-fixed-arity 5, :fn-var true, :arglists (quote ([arr i a] [arr i a j b])), :test true}, array->transient-hash-map {:protocol-inline nil, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 5579, :end-line 5579, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr])), :test true}, >= {:protocol-inline nil, :name cljs.core/>=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1905, :ret-tag boolean, :end-line 1905, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :test true}, ->TransientHashSet {:protocol-inline nil, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashSet, :variadic false, :max-fixed-arity 1}), :line 7446, :end-line 7446, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :test true}, drop-last {:protocol-inline nil, :name cljs.core/drop-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3827, :end-line 3827, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :test true}, ->ArrayIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 2}), :line 3077, :end-line 3077, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil, :test true}, object? {:protocol-inline nil, :name cljs.core/object?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 104, :ret-tag boolean, :end-line 104, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, ->ArrayNodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNodeSeq, :variadic false, :max-fixed-arity 5}), :line 6147, :end-line 6147, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, tree-map-append {:protocol-inline nil, :private true, :name cljs.core/tree-map-append, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 2}), :line 6888, :end-line 6888, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right])), :test true}, not-empty {:protocol-inline nil, :name cljs.core/not-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 3054, :end-line 3054, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll", :test true}, distinct {:protocol-inline nil, :name cljs.core/distinct, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 7632, :end-line 7632, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :test true}, partition {:protocol-inline nil, :name cljs.core/partition, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 4056, :end-line 4056, :max-fixed-arity 4, :fn-var true, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :test true}, IMultiFn {:protocol-symbol true, :name cljs.core/IMultiFn, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 8918, :protocol-info {:methods {-reset [[mf]], -add-method [[mf dispatch-val method]], -remove-method [[mf dispatch-val]], -prefer-method [[mf dispatch-val dispatch-val-y]], -get-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]]}}, :info nil, :end-line 8918, :impls #{cljs.core/MultiFn}, :test true}, fix {:protocol-inline nil, :private true, :name cljs.core/fix, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 2027, :ret-tag number, :end-line 2027, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q])), :test true}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 2331, :record false, :end-line 2331, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:protocol-symbol true, :name cljs.core/IAssociative, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 285, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 285, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :test true}, bit-flip {:protocol-inline nil, :name cljs.core/bit-flip, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2112, :end-line 2112, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n", :test true}, long-array {:protocol-inline nil, :name cljs.core/long-array, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2797, :end-line 2797, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, descendants {:protocol-inline nil, :name cljs.core/descendants, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8802, :end-line 8802, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :test true}, imul {:protocol-inline nil, :name cljs.core/imul, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 453, :ret-tag number, :end-line 453, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b])), :test true}, ->Delay {:protocol-inline nil, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Delay, :variadic false, :max-fixed-arity 2}), :line 8519, :end-line 8519, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :test true}, array-for {:protocol-inline nil, :private true, :name cljs.core/array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4221, :end-line 4221, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i])), :test true}, merge {:protocol-inline nil, :name cljs.core/merge, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 0}), :line 7309, :end-line 7309, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :test true}, ISeqable {:protocol-symbol true, :name cljs.core/ISeqable, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 332, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 332, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, js-mod {:protocol-inline nil, :name cljs.core/js-mod, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2061, :end-line 2061, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :test true}, integer? {:protocol-inline nil, :name cljs.core/integer?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1610, :ret-tag boolean, :end-line 1610, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer.", :test true}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1396, :record false, :end-line 1396, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, mapv {:protocol-inline nil, :name cljs.core/mapv, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 4}), :line 4031, :end-line 4031, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :test true}, partition-all {:protocol-inline nil, :name cljs.core/partition-all, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 7709, :end-line 7709, :max-fixed-arity 3, :fn-var true, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :test true}, partition-by {:protocol-inline nil, :name cljs.core/partition-by, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7929, :end-line 7929, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :test true}, array-map-index-of-identical? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 38, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5214, :end-line 5214, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, ISequential {:protocol-symbol true, :name cljs.core/ISequential, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 335, :protocol-info {:methods {}}, :info nil, :end-line 335, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, ->LazySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 2551, :end-line 2551, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, equiv-map {:protocol-inline nil, :private true, :name cljs.core/equiv-map, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 4986, :end-line 4986, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false.", :test true}, ->Volatile {:protocol-inline nil, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3596, :end-line 3596, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, object-array {:protocol-inline nil, :name cljs.core/object-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2837, :end-line 2837, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :test true}, Keyword {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2490, :record false, :declared true, :end-line 2490, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :test true}, derive {:protocol-inline nil, :name cljs.core/derive, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil cljs.core/IMap clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8811, :end-line 8811, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, seq-iter {:protocol-inline nil, :name cljs.core/seq-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 1}), :line 3110, :end-line 3110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, IChunkedSeq {:protocol-symbol true, :name cljs.core/IChunkedSeq, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 399, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 399, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, special-symbol? {:protocol-inline nil, :name cljs.core/special-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 9231, :ret-tag boolean, :end-line 9231, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, compare-keywords {:protocol-inline nil, :private true, :name cljs.core/compare-keywords, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 2478, :end-line 2478, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, ancestors {:protocol-inline nil, :name cljs.core/ancestors, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8794, :end-line 8794, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, subseq {:protocol-inline nil, :name cljs.core/subseq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7765, :end-line 7765, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, LazyTransformer {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 3201, :record false, :declared true, :end-line 3201, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :test true}, gensym {:protocol-inline nil, :name cljs.core/gensym, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 0} {:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1}), :line 8502, :end-line 8502, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :test true}, -next {:protocol-inline nil, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 279, :ret-tag clj-or-nil, :end-line 280, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :test true}, ->HashCollisionNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/HashCollisionNode, :variadic false, :max-fixed-arity 4}), :line 5968, :end-line 5968, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil, :test true}, delay? {:protocol-inline nil, :name cljs.core/delay?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8531, :ret-tag boolean, :end-line 8531, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay", :test true}, create-inode-seq {:protocol-inline nil, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 6130, :end-line 6130, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nodes] [nodes i s])), :test true}, flatten {:protocol-inline nil, :name cljs.core/flatten, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 4009, :end-line 4009, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :test true}, -dissoc {:protocol-inline nil, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 290, :ret-tag clj, :end-line 292, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :test true}, doubles {:protocol-inline nil, :name cljs.core/doubles, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2058, :end-line 2058, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -contains-key? {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 285, :ret-tag boolean, :end-line 286, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :test true}, remove-watch {:protocol-inline nil, :name cljs.core/remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8490, :end-line 8490, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference", :test true}, ex-info {:protocol-inline nil, :name cljs.core/ex-info, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9179, :end-line 9179, :max-fixed-arity 3, :fn-var true, :arglists (quote ([msg data] [msg data cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :test true}, ifn? {:protocol-inline nil, :name cljs.core/ifn?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1607, :ret-tag boolean, :end-line 1607, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :test true}, IAtom {:protocol-symbol true, :name cljs.core/IAtom, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 410, :protocol-info {:methods {}}, :info nil, :end-line 410, :impls #{cljs.core/Atom}, :test true}, ->PersistentQueue {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueue, :variadic false, :max-fixed-arity 5}), :line 4919, :end-line 4919, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :test true}, IWatchable {:protocol-symbol true, :name cljs.core/IWatchable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 368, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 368, :impls #{cljs.core/Atom}, :test true}, ->Stepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Stepper, :variadic false, :max-fixed-arity 2}), :line 3127, :end-line 3127, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil, :test true}, pv-fresh-node {:protocol-inline nil, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4155, :end-line 4155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit])), :test true}, subvec {:protocol-inline nil, :name cljs.core/subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 3}), :line 4680, :end-line 4680, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :test true}, -pop! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 386, :ret-tag clj, :end-line 388, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :test true}, partial {:protocol-inline nil, :name cljs.core/partial, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4} {:tag function, :variadic true, :max-fixed-arity 4}), :line 3372, :end-line 3372, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :test true}, chunked-seq? {:protocol-inline nil, :name cljs.core/chunked-seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1543, :ret-tag boolean, :end-line 1543, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, replicate {:protocol-inline nil, :name cljs.core/replicate, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3882, :end-line 3882, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs.", :test true}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4919, :record false, :end-line 4919, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :name cljs.core/min-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7691, :end-line 7691, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :test true}, hash-iset {:protocol-inline nil, :private true, :name cljs.core/hash-iset, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2247, :end-line 2247, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, reduced {:protocol-inline nil, :name cljs.core/reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 894, :end-line 894, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x", :test true}, re-matches {:protocol-inline nil, :name cljs.core/re-matches, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8061, :end-line 8061, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s.", :test true}, array-map {:protocol-inline nil, :name cljs.core/array-map, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7135, :end-line 7135, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :test true}, ITransientSet {:protocol-symbol true, :name cljs.core/ITransientSet, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 390, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 390, :impls #{cljs.core/TransientHashSet}, :test true}, ITER_SYMBOL {:file "out/cljs/core.cljs", :line 159, :column 3, :end-line 159, :end-column 20, :test true, :name cljs.core/ITER_SYMBOL}, unchecked-byte {:protocol-inline nil, :name cljs.core/unchecked-byte, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1949, :ret-tag number, :end-line 1949, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ArrayNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5862, :record false, :declared true, :end-line 5862, :skip-protocol-flag nil, :test true}, ->ChunkedSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 6}), :line 4489, :end-line 4489, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, every-pred {:protocol-inline nil, :name cljs.core/every-pred, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3654, :end-line 3654, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :test true}, keys {:protocol-inline nil, :name cljs.core/keys, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/KeySeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7230, :end-line 7230, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys.", :test true}, missing-protocol {:protocol-inline nil, :name cljs.core/missing-protocol, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag js/Error, :variadic false, :max-fixed-arity 2}), :line 137, :end-line 137, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj])), :test true}, load-file {:protocol-inline nil, :name cljs.core/load-file, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 152, :end-line 152, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file])), :test true}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5329, :record false, :end-line 5329, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :name cljs.core/distinct?, :variadic true, :file "out/cljs/core.cljs", :end-column 26, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1637, :ret-tag boolean, :end-line 1637, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :test true}, never-equiv {:file "out/cljs/core.cljs", :line 4984, :column 1, :end-line 4984, :end-column 28, :private true, :test true, :name cljs.core/never-equiv}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3127, :record false, :end-line 3127, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :name cljs.core/unchecked-short, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1951, :ret-tag number, :end-line 1951, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, ->Range {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 5}), :line 7806, :end-line 7806, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, methods {:protocol-inline nil, :name cljs.core/methods, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 9131, :end-line 9131, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :test true}, odd? {:protocol-inline nil, :name cljs.core/odd?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3325, :ret-tag boolean, :end-line 3325, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer", :test true}, ->ArrayChunk {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2636, :end-line 2636, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, lazy-transformer {:protocol-inline nil, :name cljs.core/lazy-transformer, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 1}), :line 3124, :end-line 3124, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper])), :test true}, ci-reduce {:protocol-inline nil, :private true, :name cljs.core/ci-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 920, :end-line 920, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :test true}, *3 {:file "out/cljs/core.cljs", :line 67, :column 1, :end-line 69, :end-column 6, :doc "bound in a repl thread to the third most recent value printed", :test true, :name cljs.core/*3}, -get-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 8918, :end-line 8923, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :test true}, ->Var {:protocol-inline nil, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IDeref}, :name cljs.core/->Var, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Var, :variadic false, :max-fixed-arity 3}), :line 637, :end-line 637, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IDeref}, :test true}, frequencies {:protocol-inline nil, :name cljs.core/frequencies, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7970, :end-line 7970, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :test true}, reduceable? {:protocol-inline nil, :name cljs.core/reduceable?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1526, :ret-tag boolean, :end-line 1526, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce", :test true}, string-hash-cache {:file "out/cljs/core.cljs", :line 509, :column 1, :end-line 509, :end-column 24, :test true, :name cljs.core/string-hash-cache}, rsubseq {:protocol-inline nil, :name cljs.core/rsubseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7780, :end-line 7780, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :test true}, inc {:protocol-inline nil, :name cljs.core/inc, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 884, :end-line 884, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num.", :test true}, type->str {:protocol-inline nil, :name cljs.core/type->str, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 146, :end-line 146, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty])), :test true}, obj-clone {:protocol-inline nil, :private true, :name cljs.core/obj-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 2}), :line 5036, :end-line 5036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks])), :test true}, get-method {:protocol-inline nil, :name cljs.core/get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 9135, :end-line 9135, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :test true}, vector-index-out-of-bounds {:protocol-inline nil, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 4199, :end-line 4199, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt])), :test true}, es6-entries-iterator {:protocol-inline nil, :name cljs.core/es6-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5166, :end-line 5166, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, bit-clear {:protocol-inline nil, :name cljs.core/bit-clear, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2107, :end-line 2107, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n", :test true}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7806, :record false, :end-line 7806, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :name cljs.core/filter, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3957, :end-line 3957, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :test true}, ->PersistentTreeMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 5}), :line 6463, :end-line 6463, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-array-node-seq {:protocol-inline nil, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 4}), :line 6186, :end-line 6186, :max-fixed-arity 4, :fn-var true, :arglists (quote ([nodes] [meta nodes i s])), :test true}, -assoc-n! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 386, :ret-tag clj, :end-line 387, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :test true}, IWithMeta {:protocol-symbol true, :name cljs.core/IWithMeta, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 317, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 317, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t7633 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/t7636 cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, list {:protocol-inline nil, :name cljs.core/list, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag not-native, :variadic true, :max-fixed-arity 0}), :line 2400, :end-line 2400, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& xs])), :test true}, + {:protocol-inline nil, :name cljs.core/+, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1838, :ret-tag number, :end-line 1838, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :test true}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 994, :record false, :end-line 994, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :name cljs.core/split-with, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 7924, :end-line 7924, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :test true}, ->VectorNode {:protocol-inline nil, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 2}), :line 4153, :end-line 4153, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil, :test true}, aset {:protocol-inline nil, :name cljs.core/aset, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i val] [array idx idx2 idxv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 3} {:tag any, :variadic true, :max-fixed-arity 3}), :line 199, :end-line 199, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :test true}, int-rotate-left {:protocol-inline nil, :name cljs.core/int-rotate-left, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 444, :ret-tag number, :end-line 444, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n])), :test true}, ->t7636 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7636, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta7637]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t7636, :variadic false, :max-fixed-arity 2}), :line 3059, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7637])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :test true}, keyword {:protocol-inline nil, :name cljs.core/keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Keyword clj-nil}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 2}), :line 2536, :end-line 2536, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :test true}, ->Cons {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4}), :line 2415, :end-line 2415, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, create-tree-map-seq {:protocol-inline nil, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 3}), :line 6516, :end-line 6516, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt])), :test true}, ICollection {:protocol-symbol true, :name cljs.core/ICollection, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 264, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 264, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :test true}, multi-stepper {:protocol-inline nil, :name cljs.core/multi-stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3181, :end-line 3181, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters] [xform iters nexts])), :test true}, chars {:protocol-inline nil, :name cljs.core/chars, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2054, :end-line 2054, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, str {:protocol-inline nil, :name cljs.core/str, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([] [x] [x ys]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 0} {:tag #{any string}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 2190, :end-line 2190, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :test true}, next {:protocol-inline nil, :name cljs.core/next, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 749, :ret-tag seq, :end-line 749, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :test true}, ASeq {:protocol-symbol true, :name cljs.core/ASeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 273, :protocol-info {:methods {}}, :info nil, :end-line 273, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, pr-seq-writer {:protocol-inline nil, :name cljs.core/pr-seq-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 3}), :line 8226, :end-line 8226, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts])), :test true}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3092, :record false, :end-line 3092, :skip-protocol-flag nil}, IFn {:protocol-symbol true, :name cljs.core/IFn, :file "out/cljs/core.cljs", :end-column 18, :column 1, :line 230, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 230, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :test true}, regexp? {:protocol-inline nil, :name cljs.core/regexp?, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8058, :end-line 8058, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, hash-map {:protocol-inline nil, :name cljs.core/hash-map, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic true, :max-fixed-arity 0}), :line 7126, :end-line 7126, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :test true}, underive {:protocol-inline nil, :name cljs.core/underive, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8845, :end-line 8845, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :test true}, array-copy {:protocol-inline nil, :private true, :name cljs.core/array-copy, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1561, :end-line 1561, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len])), :test true}, obj-map-compare-keys {:protocol-inline nil, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5014, :end-line 5014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -reset! {:protocol-inline nil, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 412, :end-line 413, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :test true}, -rest {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 275, :ret-tag clj, :end-line 277, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :test true}, nil-iter {:protocol-inline nil, :name cljs.core/nil-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/t7636, :variadic false, :max-fixed-arity 0}), :line 3058, :end-line 3058, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, pr-writer {:protocol-inline nil, :private true, :name cljs.core/pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8155, :end-line 8155, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :test true}, false? {:protocol-inline nil, :name cljs.core/false?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1581, :ret-tag boolean, :end-line 1581, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise.", :test true}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 4250, :record false, :end-line 4250, :skip-protocol-flag nil}, *print-readably* {:file "out/cljs/core.cljs", :line 34, :column 1, :end-line 34, :end-column 33, :dynamic true, :test true, :name cljs.core/*print-readably*}, ints {:protocol-inline nil, :name cljs.core/ints, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2056, :end-line 2056, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, some-fn {:protocol-inline nil, :name cljs.core/some-fn, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3693, :end-line 3693, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :test true}, *flush-on-newline* {:file "out/cljs/core.cljs", :line 32, :column 1, :end-line 32, :end-column 35, :dynamic true, :test true, :name cljs.core/*flush-on-newline*}, to-array {:protocol-inline nil, :name cljs.core/to-array, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2756, :end-line 2756, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start.", :test true}, build-subvec {:protocol-inline nil, :private true, :name cljs.core/build-subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4669, :end-line 4669, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :test true}, list? {:protocol-inline nil, :name cljs.core/list?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2472, :ret-tag boolean, :end-line 2472, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, tree-map-remove {:protocol-inline nil, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/BlackNode clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6945, :end-line 6945, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found])), :test true}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5968, :record false, :end-line 5968, :skip-protocol-flag nil}, array? {:protocol-inline nil, :name cljs.core/array?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 90, :ret-tag boolean, :end-line 90, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, prefers* {:protocol-inline nil, :private true, :name cljs.core/prefers*, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8871, :end-line 8871, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table])), :test true}, clone {:protocol-inline nil, :name cljs.core/clone, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 696, :end-line 696, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :test true}, scan-array {:protocol-inline nil, :private true, :name cljs.core/scan-array, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{number clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5000, :end-line 5000, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array])), :test true}, bit-not {:protocol-inline nil, :name cljs.core/bit-not, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2117, :end-line 2117, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement", :test true}, quote-string {:protocol-inline nil, :private true, :name cljs.core/quote-string, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 8146, :end-line 8146, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, byte {:protocol-inline nil, :name cljs.core/byte, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1935, :ret-tag number, :end-line 1935, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, max {:protocol-inline nil, :name cljs.core/max, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1921, :ret-tag number, :end-line 1921, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :test true}, IComparable {:protocol-symbol true, :name cljs.core/IComparable, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 393, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 393, :impls #{cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol}, :test true}, == {:protocol-inline nil, :name cljs.core/==, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2154, :ret-tag boolean, :end-line 2154, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :test true}, parents {:protocol-inline nil, :name cljs.core/parents, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8786, :end-line 8786, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :test true}, count {:protocol-inline nil, :name cljs.core/count, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1207, :end-line 1207, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :test true}, -disjoin! {:protocol-inline nil, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 390, :ret-tag clj, :end-line 391, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :test true}, *loaded-libs* {:file "out/cljs/core.cljs", :line 40, :column 1, :end-line 40, :end-column 34, :dynamic true, :test true, :name cljs.core/*loaded-libs*}, ->TransientHashMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashMap, :variadic false, :max-fixed-arity 5}), :line 6351, :end-line 6351, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ArrayChunk {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2636, :record false, :declared true, :end-line 2636, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :test true}, sorted-map-by {:protocol-inline nil, :name cljs.core/sorted-map-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/PersistentTreeMap, :variadic true, :max-fixed-arity 1}), :line 7163, :end-line 7163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :test true}, apply {:protocol-inline nil, :name cljs.core/apply, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([f args] [f x args] [f x y args] [f x y z args] [f a b c d args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic true, :max-fixed-arity 5}), :line 2982, :end-line 2982, :max-fixed-arity 5, :fn-var true, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.\n  First cut.  Not lazy.  Needs to use emitted toApply.", :test true}, get-global-hierarchy {:protocol-inline nil, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 8758, :end-line 8758, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, add-to-string-hash-cache {:protocol-inline nil, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 524, :end-line 524, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, clj->js {:protocol-inline nil, :name cljs.core/clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil object any array string clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8638, :end-line 8638, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js.", :test true}, TransientArrayMap {:num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5509, :record false, :declared true, :end-line 5509, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, ->TransientVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/TransientVector, :variadic false, :max-fixed-arity 4}), :line 4746, :end-line 4746, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :test true}, IChunkedNext {:protocol-symbol true, :name cljs.core/IChunkedNext, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 403, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 403, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :test true}, interpose {:protocol-inline nil, :name cljs.core/interpose, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3912, :end-line 3912, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :test true}, ->BlackNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/BlackNode, :variadic false, :max-fixed-arity 5}), :line 6622, :end-line 6622, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, deref {:file "out/cljs/core.cljs", :line 5590, :column 1, :end-line 5590, :end-column 79, :declared true, :test true, :name cljs.core/deref}, pv-aget {:protocol-inline nil, :private true, :name cljs.core/pv-aget, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 4158, :end-line 4158, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx])), :test true}, assoc {:protocol-inline nil, :name cljs.core/assoc, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll k v] [coll k v kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 1364, :end-line 1364, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :test true}, transient {:protocol-inline nil, :name cljs.core/transient, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2911, :end-line 2911, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time.", :test true}, -disjoin {:protocol-inline nil, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 298, :ret-tag clj, :end-line 299, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :test true}, chunk-cons {:protocol-inline nil, :name cljs.core/chunk-cons, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/ChunkedCons}, :variadic false, :max-fixed-arity 2}), :line 2732, :end-line 2732, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest])), :test true}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3077, :record false, :end-line 3077, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :name cljs.core/comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 9225, :end-line 9225, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred.", :test true}, sorted-map {:protocol-inline nil, :name cljs.core/sorted-map, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keyvals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic true, :max-fixed-arity 0}), :line 7154, :end-line 7154, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :test true}, drop-while {:protocol-inline nil, :name cljs.core/drop-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3841, :end-line 3841, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :test true}, IWriter {:protocol-symbol true, :name cljs.core/IWriter, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 353, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 353, :impls #{cljs.core/StringBufferWriter}, :test true}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7173, :record false, :end-line 7173, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :name cljs.core/realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8542, :ret-tag boolean, :end-line 8542, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :test true}, array-map-index-of-keyword? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 36, :method-params ([arr m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5192, :end-line 5192, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k])), :test true}, *print-fn* {:protocol-inline nil, :name cljs.core/*print-fn*, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 1}), :dynamic true, :line 20, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :test true}, compare {:protocol-inline nil, :name cljs.core/compare, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 1655, :ret-tag number, :end-line 1655, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :test true}, complement {:protocol-inline nil, :name cljs.core/complement, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3329, :ret-tag boolean, :end-line 3329, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :test true}, lookup-sentinel {:file "out/cljs/core.cljs", :line 1579, :column 1, :end-line 1579, :end-column 32, :private true, :test true, :name cljs.core/lookup-sentinel}, -assoc! {:protocol-inline nil, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 380, :ret-tag clj, :end-line 381, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :test true}, *print-dup* {:file "out/cljs/core.cljs", :line 36, :column 1, :end-line 36, :end-column 28, :dynamic true, :test true, :name cljs.core/*print-dup*}, string-iter {:protocol-inline nil, :name cljs.core/string-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 1}), :line 3074, :end-line 3074, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, -key->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8621, :end-line 8623, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, IDeref {:protocol-symbol true, :name cljs.core/IDeref, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 308, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 308, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :test true}, sequence {:protocol-inline nil, :name cljs.core/sequence, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll] [xform coll] [xform coll colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 3273, :end-line 3273, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :test true}, constantly {:protocol-inline nil, :name cljs.core/constantly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3339, :end-line 3339, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x.", :test true}, ->RangedIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 6}), :line 4250, :end-line 4250, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil, :test true}, chunked-seq {:protocol-inline nil, :name cljs.core/chunked-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 5}), :line 4565, :end-line 4565, :max-fixed-arity 5, :fn-var true, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :test true}, ISorted {:protocol-symbol true, :name cljs.core/ISorted, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 347, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 347, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :test true}, make-array {:protocol-inline nil, :name cljs.core/make-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 163, :ret-tag array, :end-line 163, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([size] [type size])), :test true}, shorts {:protocol-inline nil, :name cljs.core/shorts, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2055, :end-line 2055, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, *unchecked-if* {:file "out/cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 21, :test true, :name cljs.core/*unchecked-if*}, ->RSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/RSeq, :variadic false, :max-fixed-arity 3}), :line 1088, :end-line 1088, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, enable-console-print! {:protocol-inline nil, :name cljs.core/enable-console-print!, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 51, :end-line 51, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log", :test true}, -flush {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 353, :end-line 355, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :test true}, completing {:protocol-inline nil, :name cljs.core/completing, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2}), :line 1812, :end-line 1812, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f cf])), :test true}, unchecked-negate-int {:protocol-inline nil, :name cljs.core/unchecked-negate-int, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2005, :end-line 2005, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->PersistentVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentVector, :variadic false, :max-fixed-arity 6}), :line 4272, :end-line 4272, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :test true}, equiv-sequential {:protocol-inline nil, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2212, :end-line 2212, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :test true}, hash-unordered-coll {:protocol-inline nil, :name cljs.core/hash-unordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 835, :ret-tag number, :end-line 835, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :test true}, repeat {:protocol-inline nil, :name cljs.core/repeat, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3877, :end-line 3877, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :test true}, unchecked-inc {:protocol-inline nil, :name cljs.core/unchecked-inc, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1982, :end-line 1982, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, nthnext {:protocol-inline nil, :name cljs.core/nthnext, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 2180, :end-line 2180, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0.", :test true}, preserving-reduced {:protocol-inline nil, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8547, :end-line 8547, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :test true}, get-validator {:protocol-inline nil, :name cljs.core/get-validator, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 3591, :end-line 3591, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom.", :test true}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3065, :record false, :end-line 3065, :skip-protocol-flag nil}, number? {:protocol-inline nil, :name cljs.core/number?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 93, :ret-tag boolean, :end-line 93, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :test true}, -conj! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 376, :ret-tag clj, :end-line 377, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :test true}, ->PersistentArrayMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapSeq, :variadic false, :max-fixed-arity 3}), :line 5259, :end-line 5259, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, chunk-next {:protocol-inline nil, :name cljs.core/chunk-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{seq any}, :variadic false, :max-fixed-arity 1}), :line 2749, :end-line 2749, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 7698, :record false, :end-line 7698, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :name cljs.core/print-str, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([objs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8292, :end-line 8292, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "print to a string, returning it", :test true}, not-any? {:protocol-inline nil, :name cljs.core/not-any?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3314, :ret-tag boolean, :end-line 3314, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :test true}, into-array {:protocol-inline nil, :name cljs.core/into-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2}), :line 213, :ret-tag array, :end-line 213, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([aseq] [type aseq])), :test true}, -hash {:protocol-inline nil, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 329, :end-line 330, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :test true}, -dissoc! {:protocol-inline nil, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 383, :ret-tag clj, :end-line 384, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :test true}, ->Reduced {:protocol-inline nil, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 890, :end-line 890, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}, :test true}, chunk-buffer {:protocol-inline nil, :name cljs.core/chunk-buffer, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 1}), :line 2633, :end-line 2633, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity])), :test true}, seqable? {:protocol-inline nil, :name cljs.core/seqable?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1599, :ret-tag boolean, :end-line 1599, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable", :test true}, symbol? {:protocol-inline nil, :name cljs.core/symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 572, :ret-tag boolean, :end-line 572, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :test true}, m3-hash-unencoded-chars {:protocol-inline nil, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 490, :ret-tag number, :end-line 490, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in])), :test true}, unchecked-char {:protocol-inline nil, :name cljs.core/unchecked-char, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1950, :ret-tag number, :end-line 1950, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x])), :test true}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4977, :record false, :end-line 4977, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4} {:tag any, :variadic false, :max-fixed-arity 5} {:tag any, :variadic false, :max-fixed-arity 6} {:tag any, :variadic false, :max-fixed-arity 7} {:tag any, :variadic false, :max-fixed-arity 8} {:tag any, :variadic false, :max-fixed-arity 9} {:tag any, :variadic false, :max-fixed-arity 10} {:tag any, :variadic false, :max-fixed-arity 11} {:tag any, :variadic false, :max-fixed-arity 12} {:tag any, :variadic false, :max-fixed-arity 13} {:tag any, :variadic false, :max-fixed-arity 14} {:tag any, :variadic false, :max-fixed-arity 15} {:tag any, :variadic false, :max-fixed-arity 16} {:tag any, :variadic false, :max-fixed-arity 17} {:tag any, :variadic false, :max-fixed-arity 18} {:tag any, :variadic false, :max-fixed-arity 19} {:tag any, :variadic false, :max-fixed-arity 20} {:tag any, :variadic false, :max-fixed-arity 21} {:tag any, :variadic false, :max-fixed-arity 22}), :line 230, :end-line 231, :max-fixed-arity 22, :fn-var true, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :test true}, coll? {:protocol-inline nil, :name cljs.core/coll?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1500, :ret-tag boolean, :end-line 1500, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection", :test true}, get-in {:protocol-inline nil, :added "1.2", :name cljs.core/get-in, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 4078, :end-line 4078, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :test true}, fnext {:protocol-inline nil, :name cljs.core/fnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1158, :end-line 1158, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))", :test true}, IList {:protocol-symbol true, :name cljs.core/IList, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 338, :protocol-info {:methods {}}, :info nil, :end-line 338, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :test true}, List {:num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2270, :record false, :declared true, :end-line 2270, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :test true}, -val {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 294, :end-line 296, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, bytes {:protocol-inline nil, :name cljs.core/bytes, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2053, :end-line 2053, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}, ->ObjMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :methods ({:tag cljs.core/ObjMap, :variadic false, :max-fixed-arity 5}), :line 5046, :end-line 5046, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :test true}, compare-symbols {:protocol-inline nil, :private true, :name cljs.core/compare-symbols, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 580, :end-line 580, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b])), :test true}, -seq {:protocol-inline nil, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 332, :ret-tag clj-or-nil, :end-line 333, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :test true}}, :name cljs.core, :doc nil, :excludes #{}, :use-macros nil, :require-macros nil, :uses nil, :requires {StringBuffer goog.string.StringBuffer, garray goog.array, goog.array goog.array, gobject goog.object, goog.object goog.object, goog.string goog.string, gstring goog.string}, :imports {StringBuffer goog.string.StringBuffer}}