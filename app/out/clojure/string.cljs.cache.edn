;; Analyzed by ClojureScript 0.0-2725
{:defs {seq-reverse {:protocol-inline nil, :private true, :name clojure.string/seq-reverse, :variadic false, :file "out/clojure/string.cljs", :end-column 20, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 14, :end-line 14, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, capitalize {:protocol-inline nil, :name clojure.string/capitalize, :variadic false, :file "out/clojure/string.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 78, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :test true}, reverse {:protocol-inline nil, :name clojure.string/reverse, :variadic false, :file "out/clojure/string.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 21, :end-line 21, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns s with its characters reversed.", :test true}, join {:protocol-inline nil, :name clojure.string/join, :variadic false, :file "out/clojure/string.cljs", :end-column 12, :method-params ([coll] [separator coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2}), :line 49, :end-line 49, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [separator coll])), :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :test true}, replace-first {:protocol-inline nil, :name clojure.string/replace-first, :variadic false, :file "out/clojure/string.cljs", :end-column 21, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 40, :end-line 40, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :test true}, escape {:protocol-inline nil, :name clojure.string/escape, :variadic false, :file "out/clojure/string.cljs", :end-column 14, :method-params ([s cmap]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 179, :end-line 179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s cmap])), :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :test true}, discard-trailing-if-needed {:protocol-inline nil, :private true, :name clojure.string/discard-trailing-if-needed, :variadic false, :file "out/clojure/string.cljs", :end-column 35, :method-params ([limit v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 103, :end-line 103, :max-fixed-arity 2, :fn-var true, :arglists (quote ([limit v])), :test true}, pop-last-while-empty {:protocol-inline nil, :private true, :name clojure.string/pop-last-while-empty, :variadic false, :file "out/clojure/string.cljs", :end-column 29, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 96, :end-line 96, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :test true}, replace {:protocol-inline nil, :name clojure.string/replace, :variadic false, :file "out/clojure/string.cljs", :end-column 15, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 27, :end-line 27, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :test true}, split-lines {:protocol-inline nil, :name clojure.string/split-lines, :variadic false, :file "out/clojure/string.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 142, :end-line 142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Splits s on \n or \r\n.", :test true}, lower-case {:protocol-inline nil, :name clojure.string/lower-case, :variadic false, :file "out/clojure/string.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 73, :end-line 73, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all lower-case.", :test true}, trim-newline {:protocol-inline nil, :name clojure.string/trim-newline, :variadic false, :file "out/clojure/string.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any string}, :variadic false, :max-fixed-arity 1}), :line 162, :end-line 162, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :test true}, upper-case {:protocol-inline nil, :name clojure.string/upper-case, :variadic false, :file "out/clojure/string.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 68, :end-line 68, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all upper-case.", :test true}, split {:protocol-inline nil, :name clojure.string/split, :variadic false, :file "out/clojure/string.cljs", :end-column 13, :method-params ([s re] [s re limit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 119, :end-line 119, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s re] [s re limit])), :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :test true}, trimr {:protocol-inline nil, :name clojure.string/trimr, :variadic false, :file "out/clojure/string.cljs", :end-column 13, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 157, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the right side of string.", :test true}, trim {:protocol-inline nil, :name clojure.string/trim, :variadic false, :file "out/clojure/string.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 147, :end-line 147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from both ends of string.", :test true}, triml {:protocol-inline nil, :name clojure.string/triml, :variadic false, :file "out/clojure/string.cljs", :end-column 13, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 152, :end-line 152, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the left side of string.", :test true}, blank? {:protocol-inline nil, :name clojure.string/blank?, :variadic false, :file "out/clojure/string.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 174, :end-line 174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "True is s is nil, empty, or contains only whitespace.", :test true}, re-surrogate-pair {:file "out/clojure/string.cljs", :line 18, :column 1, :end-line 18, :end-column 34, :private true, :test true, :name clojure.string/re-surrogate-pair}, split-with-empty-regex {:protocol-inline nil, :private true, :name clojure.string/split-with-empty-regex, :variadic false, :file "out/clojure/string.cljs", :end-column 31, :method-params ([s limit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 109, :end-line 109, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s limit])), :test true}}, :name clojure.string, :doc nil, :excludes #{reverse replace}, :use-macros nil, :require-macros nil, :uses nil, :requires {StringBuffer goog.string.StringBuffer, goog.string goog.string, gstring goog.string}, :imports {StringBuffer goog.string.StringBuffer}}